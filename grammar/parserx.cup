package grammar;

import com.github.jhoenicke.javacup.runtime.*;
import nodes.*;
import rule.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

action code{:
  Tree tree=new Tree();
  OrRule lastOr=null;
:};

parser code {:
    public void report_fatal_error(
    String   message,
    Object   info)
    {
      done_parsing();
      if (info instanceof Symbol){
        System.out.println(message+ "\nCan't recover from previous error(s), giving up. @"+(Symbol)info);
      }
      else{
        System.out.println(message + "\nCan't recover from previous error(s), giving up. @"+cur_token);
      }
      //System.exit(1);
    }

    public void report_error(String message, Object info)
    {
      if (info instanceof Symbol)
         System.out.println(message+" @"+((Symbol)info).value);
      else
         System.out.println(message+" @"+cur_token.value);
    }
:}

/* define how to connect to the scanner! */
//init with {: s.init(); :};
//scan with {: return s.next_token(); :};

terminal STAR, PLUS, QUES, OR;
terminal SEMI, COLON,COMMA, EQ, LPAREN, RPAREN;
terminal TOKEN;
terminal String IDENT;
//terminal Integer    NUMBER;        // our scanner provides numbers as integers

/* Non terminals */
non terminal Node tree;
non terminal tokenDecl,tokenDecls;
non terminal RuleDecl ruleDecl,eqOrColon;
non terminal nameList;
non terminal StarRule starRule;
non terminal PlusRule plusRule;
non terminal OptionalRule optionalRule;
non terminal GroupRule groupRule;
non terminal OrRule orRule;
non terminal orSingle, orList;
non terminal Rule single, singleNoOr, nameRule;

/*precedence left PLUS, MINUS;
precedence left TIMES;
precedence left UMINUS;*/




start with tree;

tree ::= tokenDecl* ruleDecl*
  {:RESULT=tree;:};
//tokenDecls ::= tokenDecl*;
              
tokenDecl ::= TOKEN nameList SEMI ;
nameList ::= IDENT+:arr
  {:
    for(String tn:arr){
      System.out.println("tn="+tn);
      tree.add(new TokenDecl(tn));
    }
  :} ;
            

ruleDecl ::= IDENT:n eqOrColon rhs_list:a SEMI
     {:
     RESULT=new RuleDecl(n);
     RESULT.addAll((List)Arrays.asList(a));
     tree.add(RESULT);
     :};
eqOrColon ::= EQ | COLON;

rhs_list :: rhs_list OR singleNoOr | singleNoOr;

single ::= orRule:or{:RESULT=or;:}
         | singleNoOr:s{:RESULT=s:};

starRule ::= groupRule:g STAR{:RESULT=new StarRule(g);:}
           | nameRule:n STAR{:RESULT=new StarRule(n);:};
           
plusRule ::= groupRule:g PLUS{:RESULT=new PlusRule(g);:}
           | nameRule:n PLUS{:RESULT=new PlusRule(n);:};
           
optionalRule ::= groupRule:g QUES{:RESULT=new OptionalRule(g);:}
           | nameRule:n QUES{:RESULT=new OptionalRule(n);:};
           
groupRule ::= LPAREN single+:a RPAREN
   {:
     RESULT=new GroupRule();
     RESULT.addAll(Arrays.asList(a));
   :};
nameRule ::= IDENT:n{:RESULT=new RuleRef(n);:};

orRule ::= orList
   {:
   lastOr=new OrRule();
   RESULT=lastOr;
   :};
          
orList ::= orList OR singleNoOr:r{:RESULT=s;:}
         | singleNoOr:s;
         
singleNoOr ::= 
           starRule:s{:RESULT=s;:}
         | plusRule:p{:RESULT=p;:}
         | optionalRule:o{:RESULT=o;:}
         | groupRule:g{:RESULT=g;:}
         | nameRule:n{:RESULT=n;:};
         
//orSingle ::= single:s {::};
